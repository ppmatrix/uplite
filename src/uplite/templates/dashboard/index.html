<!-- Dashboard Template - Updated: 2025-08-13 23:05 -->
{% extends "base.html" %}

{% block title %}Dashboard - UpLite{% endblock %}

{% block head %}
<style>
.widget-container {
    margin-bottom: 20px;
}

.widget {
    background: transparent;
    border: none;
    box-shadow: none;
}

.widget-header {
    background: #f8f9fa;
    border-bottom: 1px solid #ddd;
    border-radius: 8px 8px 0 0;
    padding: 15px 20px;
    font-weight: bold;
    font-size: 1.1rem;
}

.widget-body {
    padding: 20px;
    background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
    border-radius: 12px;
}

.connection-summary {
    margin-bottom: 25px;
}

/* 5-Column Connection Layout */
.connection-item {
    display: flex;
    align-items: center;
    padding: 10px 14px;
    border: 1px solid #d0d7de;
    border-radius: 8px;
    background: #ffffff;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
    cursor: pointer;
    text-decoration: none;
    color: #24292f;
    min-height: 50px;
    height: 100%;
    width: 100%;
}

.connection-column {
    display: flex;
    align-items: center;
    height: 100%;
}

/* Column 1: Status LED */
.connection-status {
    width: 18px;
    justify-content: center;
    flex-shrink: 0;
}

/* Column 2: Connection Info */
.connection-info {
    flex: 1;
    min-width: 110px;
    padding-left: 10px;
    flex-direction: column;
    align-items: flex-start;
    justify-content: center;
}

/* Column 3: Chart */
.connection-chart {
    width: 80px;
    justify-content: center;
    flex-shrink: 0;
    margin: 0 6px;
}

/* Column 4: Time Badge */
.connection-time {
    width: 55px;
    justify-content: center;
    flex-shrink: 0;
}

/* Column 5: External Link */
.connection-link {
    width: 18px;
    justify-content: center;
    flex-shrink: 0;
    margin-left: 6px;
}

.link-placeholder {
    width: 16px;
    height: 16px;
}

.connections-list {
    margin-left: -15px;
    margin-right: -15px;
}

.connections-list .col-lg-6 {
    padding-left: 15px;
    padding-right: 15px;
}

.connection-item:hover {
    background: #f6f8fa;
    border-color: #0969da;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(9,105,218,0.25);
    text-decoration: none;
    color: #24292f;
}

.connection-item.status-up:hover {
    background: #f6ffed;
    border-color: #1f883d;
    box-shadow: 0 4px 12px rgba(31,136,61,0.25);
}

.connection-item.status-down:hover {
    background: #ffebee;
    border-color: #da3633;
    box-shadow: 0 4px 12px rgba(218,54,51,0.25);
}

.non-clickable {
    cursor: default !important;
}

.non-clickable:hover {
    transform: none !important;
    background: #fafafa !important;
    border-color: #e9ecef !important;
    box-shadow: none !important;
}

/* Status LED */
.status-led {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    margin-right: 15px;
    flex-shrink: 0;
    position: relative;
}

.status-led.status-up {
    background-color: #28a745;
    box-shadow: 0 0 8px rgba(40,167,69,0.4);
}

.status-led.status-down {
    background-color: #dc3545;
    box-shadow: 0 0 8px rgba(220,53,69,0.4);
}

.status-led.status-unknown {
    background-color: #6c757d;
    box-shadow: 0 0 8px rgba(108,117,125,0.4);
}

.status-led.status-up::after {
    content: '';
    position: absolute;
    width: 6px;
    height: 6px;
    background-color: #34d058;
    border-radius: 50%;
    top: 3px;
    left: 3px;
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
}

/* Connection Info */
.connection-info {
    grid-area: info;
    min-width: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: flex-start;
    gap: 2px;
    overflow: hidden;
}

.connection-name {
    font-weight: 600;
    font-size: 1rem;
    color: #333;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
    line-height: 1.2;
}

.connection-description {
    color: #6c757d;
    font-size: 0.85rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
    line-height: 1.1;
    margin-top: -2px;
}

/* Color-coded response time badges */
    gap: 15px;
    overflow: hidden;
}

.connection-name {
    font-weight: 600;
    font-size: 1rem;
    color: #333;
    white-space: nowrap;
    min-width: 120px;
}

.connection-description {
    color: #6c757d;
    font-size: 0.9rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    min-width: 150px;
}





/* Scrolling line chart */
.ping-chart-container {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 20px;
    width: 80px;
    background: transparent;
}

.no-chart-data {
    color: #6c757d;
    font-size: 0.8rem;
    text-align: center;
    width: 100%;
}

.chart-line {
    fill: none;
    stroke: #059669;
    stroke-width: 1.5;
    vector-rendering: crispEdges;
    filter: drop-shadow(0 1px 1px rgba(0,0,0,0.1));
}

/* Simple chart styling */




/* Response time display */
.response-time-display {
    font-size: 0.75rem;
    font-weight: 700;
    white-space: nowrap;
    padding: 0.3em 0.6em;
    border-radius: 0.5rem;
    line-height: 1;
    min-width: 50px;
    text-align: center;
    border: 1px solid rgba(0,0,0,0.1);
    text-shadow: 0 1px 1px rgba(0,0,0,0.1);
}

.clean-dashboard-title {
    color: #1f2937;
    font-weight: 600;
    margin-bottom: 30px;
    text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

.refresh-btn {
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.external-link-icon {
    margin-left: 10px;
    color: #007bff;
    font-size: 0.9rem;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.connection-item:hover .external-link-icon {
    opacity: 1;
}

.non-clickable .external-link-icon {
    display: none;
}

/* Responsive adjustments for connection items */
@media (max-width: 768px) {
    .connection-item {
        min-height: 60px;
        padding: 10px 15px;
    }
    
    .connection-name {
        font-size: 0.9rem;
    }
    
    .connection-description {
        font-size: 0.8rem;
    }
}

@media (min-width: 1200px) {
    .connections-list .col-lg-4 {
        flex: 0 0 33.333333%;
        max-width: 33.333333%;
    }
}

@media (min-width: 992px) and (max-width: 1199px) {
    .connections-list .col-md-6 {
        flex: 0 0 50%;
        max-width: 50%;
    }
}
</style>
{% endblock %}

{% block content %}
<div class="d-flex justify-content-between align-items-center mb-4">
    <h1 class="clean-dashboard-title"><i class="bi bi-activity"></i> Connection Monitoring</h1>
    <button id="refresh-dashboard" class="btn btn-outline-primary refresh-btn">
        <i class="bi bi-arrow-clockwise"></i> Refresh
    </button>
</div>

<div class="row" id="dashboard-widgets">
    {% for widget_config in widget_configs %}
    <div class="col-12 widget-container">
        <div class="widget widget-{{ widget_config.widget_type }}">
            
            <div class="widget-body" id="widget-{{ widget_config.id }}-body">
                <div class="text-center">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Loading connection status...</p>
                </div>
            </div>
        </div>
    </div>
    {% else %}
    <div class="col-12">
        <div class="alert alert-info">
            <i class="bi bi-info-circle"></i>
            <strong>Clean Dashboard Setup</strong><br>
            Your dashboard is now focused on connection monitoring. 
            <a href="{{ url_for('dashboard.connections') }}">Manage connections</a> to customize what you monitor.
        </div>
    </div>
    {% endfor %}
</div>
{% endblock %}

{% block scripts %}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Load widget data
    loadAllWidgets();
    
    // Set up refresh button
    document.getElementById('refresh-dashboard').addEventListener('click', function() {
        const button = this;
        const originalHtml = button.innerHTML;
        button.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i> Refreshing...';
        button.disabled = true;
        
        loadAllWidgets().finally(() => {
            button.innerHTML = originalHtml;
            button.disabled = false;
        });
    });
    
    // Auto-refresh every 30 seconds
    setInterval(loadAllWidgets, 30000);
});

function loadAllWidgets() {
    const widgets = document.querySelectorAll('[id^="widget-"][id$="-body"]');
    const promises = [];
    
    widgets.forEach(widget => {
        const widgetId = widget.id.match(/widget-(\d+)-body/)[1];
        promises.push(loadWidgetData());
    });
    
    return Promise.all(promises);
}

function loadWidgetData() {
    const widgetBody = document.querySelector("[id$='-body']");
    
    return fetch(`/api/dashboard/refresh`)
        .then(response => {
            console.log("API response status:", response.status);
            if (response.status === 401 || response.status === 403) {
                throw new Error("Authentication required - please refresh the page and login");
            }
            if (!response.ok) {
                throw new Error(`API error: ${response.status} ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            if (data.error) {
                widgetBody.innerHTML = `<div class="alert alert-danger"><i class="bi bi-exclamation-triangle"></i> ${data.error}</div>`;
            } else {
                renderConnectionMonitor(data);
            }
        })
        .catch(error => {
            console.error("‚ùå Error loading connection data:", error);
            widgetBody.innerHTML = `<div class="alert alert-danger"><i class="bi bi-wifi-off"></i> Failed to load connection data: ${error.message}</div>`;
            console.error('Widget load error:', error);
        });
}

function isClickableUrl(url) {
    if (!url) return false;
    if (url.startsWith('http://') || url.startsWith('https://')) {
        return true;
    }
    if (/^\d+\.\d+\.\d+\.\d+$/.test(url)) {
        return false;
    }
    return false;
}

function makeConnectionClickable(element, url, connectionName) {
    if (!isClickableUrl(url)) {
        element.classList.add('non-clickable');
        return;
    }
    
    element.addEventListener('click', function(e) {
        e.preventDefault();
        window.open(url, '_blank', 'noopener,noreferrer');
    });
}

function renderConnectionMonitor(data) {
    console.log("üìä renderConnectionMonitor called with:", data);
    
    const widgetBody = document.querySelector('[id^="widget-"][id$="-body"]');
    
    if (!widgetBody) {
        console.error("‚ùå Widget body element not found!");
        return;
    }
    
    if (!data) {
        console.error("‚ùå No data provided to renderConnectionMonitor");
        widgetBody.innerHTML = '<div class="alert alert-danger">No data received from API</div>';
        return;
    }
    
    if (!data.connections || data.connections.length === 0) {
        console.log("‚ö†Ô∏è No connections in data");
        widgetBody.innerHTML = '<div class="alert alert-warning">No connection data available</div>';
        return;
    }
    
    console.log(`‚úÖ Processing ${data.connections.length} connections`);
    
    // Generate summary section from connection data
    const upCount = data.connections.filter(conn => conn.last_status === 'up').length;
    const downCount = data.connections.filter(conn => conn.last_status === 'down').length;
    const totalCount = data.connections.length;
    
    const overallStatus = downCount === 0 ? 'success' : (upCount === 0 ? 'danger' : 'warning');
    const overallMessage = downCount === 0 ? 'All services operational' : 
                          upCount === 0 ? 'All services down' : 
                          `${downCount} service${downCount > 1 ? 's' : ''} experiencing issues`;
    
    const summaryHtml = `
        <div class="connection-summary">
            <div class="alert alert-${overallStatus} d-flex justify-content-between align-items-center">
                <div>
                    <strong><i class="bi bi-hdd-network"></i> ${overallMessage}</strong>
                    <div class="mt-2">
                        <small>
                            <span class="badge bg-secondary me-2">Total: ${totalCount}</span>
                            <span class="badge bg-success me-2">Up: ${upCount}</span>
                            ${downCount > 0 ? `<span class="badge bg-danger me-2">Down: ${downCount}</span>` : ''}
                            ${data.connections.filter(conn => conn.last_status === 'unknown').length > 0 ? `<span class="badge bg-warning me-2">Unknown: ${data.connections.filter(conn => conn.last_status === 'unknown').length}</span>` : ''}
                        </small>
                    </div>
                </div>
                <div class="text-end">
                    <small class="text-muted">
                        <i class="bi bi-clock"></i> 
                        Updated ${new Date().toLocaleTimeString()}
                    </small>
                </div>
            </div>
        </div>
    `;
    
    // Generate connections list
    let connectionsHtml = '<div class="connections-list row">';
    
    // Debug: Log full API response
    console.log("Full API response:", data);
    console.log("Connections array:", data.connections);
    console.log("Number of connections:", data.connections ? data.connections.length : 0);
    
    if (!data.connections || data.connections.length === 0) {
        console.error("‚ùå No connections in API response!");
        widgetBody.innerHTML = '<div class="alert alert-warning">No connections found in API response</div>';
        return;
    }
    
    
    
    // Generate sample historical data as fallback when no real data available
    function generateSampleHistory(conn) {
        const baseTime = conn.median_response_time || conn.last_response_time || 100;
        const variance = baseTime * 0.3; // 30% variance
        const history = [];
        
        for (let i = 0; i < 20; i++) {
            const time = baseTime + (Math.random() - 0.5) * variance;
            const status = Math.random() > 0.1 ? 'up' : 'down'; // 90% uptime
            history.push({
                timestamp: Date.now() - (20 - i) * 60000, // 1 minute intervals
                last_response_time: Math.max(1, time),
                status: status
            });
        }
        return history;
    }
    
    // Create ultra-minimal SVG line chart
    function createSVGChart(history, currentStatus) {
        const width = 80;
        const height = 20;
        
        // Handle both real history data and sample data formats
        const validData = history.filter(h => {
            const responseTime = h.response_time || h.last_response_time;
            const status = h.status;
            return responseTime && status === 'up';
        });
        
        if (validData.length < 2) {
            return `<div class="no-chart-data">‚Äî</div>`;
        }
        
        // Use full SVG space - no padding
        const responseTimes = validData.map(h => h.response_time || h.last_response_time);
        const minTime = Math.min(...responseTimes);
        const maxTime = Math.max(...responseTimes);
        const timeRange = maxTime - minTime || 1;
        
        // Generate path that fills entire SVG space
        const pathData = validData.map((h, i) => {
            const responseTime = h.response_time || h.last_response_time;
            const x = (i / (validData.length - 1)) * width;
            const y = height - ((responseTime - minTime) / timeRange) * height;
            return `${i === 0 ? 'M' : 'L'}${x},${y}`;
        }).join(' ');
        
        // Enhanced colors for better contrast
        const color = currentStatus === 'up' ? '#059669' : '#dc2626';
        
        return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" style="display:block;background:transparent;"><path d="${pathData}" fill="none" stroke="${color}" stroke-width="1" vector-rendering="crispEdges"/></svg>`;
    }

    
    data.connections.forEach((conn, index) => {
        console.log(`Processing connection ${index + 1}:`, {
            name: conn.name,
            last_status: conn.last_status,
            last_response_time: conn.last_response_time,
            target: conn.target
        });
        const isClickable = isClickableUrl(conn.target);
        const statusClass = conn.last_status === 'up' ? 'status-up' : conn.last_status === 'down' ? 'status-down' : 'status-unknown';
        const ledClass = `status-${conn.last_status}`;
        
        // Generate historical chart data
        const generateChart = (conn) => {
            // Use real historical data if available, fallback to sample data
            const historyData = conn.history && conn.history.length > 0 ? conn.history : generateSampleHistory(conn);
            return createSVGChart(historyData, conn.last_status);
        };
        
        connectionsHtml += `
        <div class="col-lg-4 col-md-6 col-sm-12 mb-3">
            <div class="connection-item ${statusClass}" data-url="${conn.target}" data-name="${conn.name}">
                <div class="connection-column connection-status">
                    <div class="status-led ${ledClass}"></div>
                </div>
                <div class="connection-column connection-info">
                    <div class="connection-name">${conn.name}</div>
                    <div class="connection-description">${conn.description || conn.target}</div>
                </div>
                <div class="connection-column connection-chart">
                    <div class="ping-chart-container">${generateChart(conn)}</div>
                </div>
                <div class="connection-column connection-time">
                    ${(() => {
                    console.log(`Time badge for ${conn.name}:`, {
                        median_response_time: conn.median_response_time,
                        last_response_time: conn.last_response_time
                    });
                    
                    const responseTime = conn.median_response_time || conn.last_response_time;
                    if (!responseTime) {
                        console.log(`No response time data for ${conn.name}`);
                        return '<div class="response-time-display badge bg-danger">ERR</div>';
                    }
                    
                    let colorClass = 'badge bg-danger';
                    if (responseTime < 100) {
                        colorClass = 'badge bg-success';
                    } else if (responseTime < 300) {
                        colorClass = 'badge bg-warning text-dark';
                    } else if (responseTime < 1000) {
                        colorClass = 'badge bg-warning';
                    }
                    
                    const roundedTime = Math.round(responseTime);
                    const title = conn.median_response_time ? 'Median response time' : 'Current response time';
                    
                    console.log(`Badge for ${conn.name}: ${roundedTime}ms (${colorClass})`);
                    return `<div class="response-time-display ${colorClass}" title="${title}">${roundedTime}ms</div>`;
                })()}
                </div>
                <div class="connection-column connection-link">
                    ${isClickable ? '<i class="bi bi-box-arrow-up-right external-link-icon"></i>' : '<span class="link-placeholder"></span>'}
                </div>
            </div>
        </div>
        `;
    });
    connectionsHtml += '</div>';
    
    widgetBody.innerHTML = summaryHtml + connectionsHtml;
    
    // Add click handlers to clickable connections
    const connectionItems = widgetBody.querySelectorAll('.connection-item');
    connectionItems.forEach(item => {
        const url = item.dataset.url;
        const name = item.dataset.name;
        makeConnectionClickable(item, url, name);
    });
}
</script>

<style>
.spin {
    animation: spin 1s linear infinite;
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* Responsive adjustments for connection items */
@media (max-width: 768px) {
    .connection-item {
        min-height: 60px;
        padding: 10px 15px;
    }
    
    .connection-name {
        font-size: 0.9rem;
    }
    
    .connection-description {
        font-size: 0.8rem;
    }
}

@media (min-width: 1200px) {
    .connections-list .col-lg-4 {
        flex: 0 0 33.333333%;
        max-width: 33.333333%;
    }
}

@media (min-width: 992px) and (max-width: 1199px) {
    .connections-list .col-md-6 {
        flex: 0 0 50%;
        max-width: 50%;
    }
}
</style>
{% endblock %}
